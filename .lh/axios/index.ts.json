{
    "sourceFile": "axios/index.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1651396192451,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1651396192451,
            "name": "Commit-0",
            "content": "// index.ts\r\nimport axios, { AxiosRequestConfig, Method } from \"axios\";\r\nimport router from \"@/router\";\r\nimport store from \"@/store\";\r\nimport { ElMessage as message } from 'element-plus'\r\nimport { storage } from \"../storage/storage\";\r\nimport { dataList } from \"@/components/aspin/data\";\r\n\r\n/** \r\n * 跳转登录页\r\n * 携带当前页面路由，以期在登录页面完成登录后返回当前页面\r\n */\r\nconst toLogin = () => {\r\n  router.replace({\r\n    name: 'LoginPage',\r\n  });\r\n}\r\n\r\n/** \r\n * 请求失败后的错误统一处理 \r\n * @param {Number} status 请求失败的状态码\r\n */\r\nconst errorHandle = (status: number, other: string) => {\r\n  // 状态码判断\r\n  switch (status) {\r\n\r\n    case 302: message.error('接口重定向了！');\r\n      break;\r\n    case 400:\r\n      message.error(\"发出的请求有错误，服务器没有进行新建或修改数据的操作==>\" + status)\r\n      break;\r\n    // 401: 未登录\r\n    // 未登录则跳转登录页面，并携带当前页面的路径\r\n    // 在登录成功后返回当前页面，这一步需要在登录页操作。                \r\n    case 401: //重定向\r\n      message.error(\"token:登录失效==>\" + status + \":\" + store.state.Roles)\r\n      storage.remove(store.state.Roles)\r\n      storage.get(store.state.Roles)\r\n      router.replace({\r\n        path: '/Login',\r\n      });\r\n      break;\r\n    // 403 token过期\r\n    // 清除token并跳转登录页\r\n    case 403:\r\n      message.error(\"登录过期,用户得到授权，但是访问是被禁止的==>\" + status)\r\n      // store.commit('token', null);\r\n      setTimeout(() => {\r\n        router.replace({\r\n          path: '/Login',\r\n        });\r\n      }, 1000);\r\n      break;\r\n    case 404:\r\n      message.error(\"网络请求不存在==>\" + status)\r\n      break;\r\n    case 406:\r\n      message.error(\"请求的格式不可得==>\" + status)\r\n      break;\r\n    case 408: message.error(\" 请求超时！\")\r\n      break;\r\n    case 410:\r\n      message.error(\"请求的资源被永久删除，且不会再得到的==>\" + status)\r\n      break;\r\n    case 422:\r\n      message.error(\"当创建一个对象时，发生一个验证错误==>\" + status)\r\n      break;\r\n    case 500:\r\n      message.error(\"服务器发生错误，请检查服务器==>\" + status)\r\n      break;\r\n    case 502:\r\n      message.error(\"网关错误==>\" + status)\r\n      break;\r\n    case 503:\r\n      message.error(\"服务不可用，服务器暂时过载或维护==>\" + status)\r\n      break;\r\n    case 504:\r\n      message.error(\"网关超时==>\" + status)\r\n      break;\r\n    default:\r\n      message.error(\"其他错误错误==>\" + status)\r\n  }\r\n}\r\n\r\n// 定义接口\r\ninterface PendingType {\r\n  url?: string;\r\n  method?: Method;\r\n  params: any;\r\n  data: any;\r\n  cancel: any;\r\n}\r\n// 取消重复请求\r\nconst pending: Array<PendingType> = [];\r\nconst CancelToken = axios.CancelToken;\r\n\r\n// 移除重复请求\r\nconst removePending = (config: AxiosRequestConfig) => {\r\n  for (const key in pending) {\r\n    const item: number = +key;\r\n    const list: PendingType = pending[key];\r\n    // 当前请求在数组中存在时执行函数体\r\n    if (list.url === config.url && list.method === config.method && JSON.stringify(list.params) === JSON.stringify(config.params) && JSON.stringify(list.data) === JSON.stringify(config.data)) {\r\n      // 执行取消操作\r\n      list.cancel('操作太频繁，请稍后再试');\r\n      // 从数组中移除记录\r\n      pending.splice(item, 1);\r\n    }\r\n  }\r\n};\r\n\r\n/* 实例化请求配置 */\r\nconst instance = axios.create({\r\n  headers: {\r\n    //php 的 post 传输请求头一定要这个 不然报错 接收不到值\r\n    \"Content-Type\": \"application/json;charset=UTF-8\",\r\n    \"Access-Control-Allow-Origin-Type\": '*'\r\n  },\r\n  // 请求时长\r\n  timeout: 1000 * 30,\r\n  // 请求的base地址 TODO:这块以后根据不同的模块调不同的api\r\n  baseURL: process.env.VUE_APP_API_URL,\r\n  //     ? \"测试\"\r\n  //     : \"正式\",\r\n  // 表示跨域请求时是否需要使用凭证\r\n  withCredentials: false,\r\n})\r\n\r\n/** \r\n * 请求拦截器 \r\n * 每次请求前，如果存在token则在请求头中携带token \r\n */\r\ninstance.interceptors.request.use(\r\n  config => {\r\n\r\n    removePending(config);\r\n    config.cancelToken = new CancelToken((c) => {\r\n      pending.push({ url: config.url, method: config.method, params: config.params, data: config.data, cancel: c });\r\n    });\r\n    // 登录流程控制中，根据本地是否存在token判断用户的登录情况        \r\n    // 但是即使token存在，也有可能token是过期的，所以在每次的请求头中携带token        \r\n    // 后台根据携带的token判断用户的登录情况，并返回给我们对应的状态码        \r\n    // 而后我们可以在响应拦截器中，根据状态码进行一些统一的操作。        \r\n    // const token = store.state.token;\r\n    // localStorage.setItem('token', token);\r\n\r\n    if (storage.get(store.state.Roles)) {\r\n      store.state.Roles\r\n      config.headers.Authorization = storage.get(store.state.Roles);\r\n    }\r\n    return config;\r\n  },\r\n  error => {\r\n    message.error(error.data.error.message);\r\n    return Promise.reject(error.data.error.message);\r\n  }\r\n\r\n)\r\n\r\n// 响应拦截器\r\ninstance.interceptors.response.use(function (config) {\r\n\r\n  dataList.show = true\r\n  removePending(config.config);\r\n  // 请求成功\r\n  if (config.status === 200 || config.status === 204) {\r\n    setTimeout(() => {\r\n      dataList.show = false\r\n    }, 400)\r\n    return Promise.resolve(config);\r\n  } else {\r\n    return Promise.reject(config);\r\n  }\r\n  // 请求失败\r\n}, function (error) {\r\n\r\n  const { response } = error;\r\n  if (response) {\r\n    errorHandle(response.status, response.data.message);\r\n\r\n    // 超时重新请求\r\n    const config = error.config;\r\n    // 全局的请求次数,请求的间隙\r\n    const [RETRY_COUNT, RETRY_DELAY] = [3, 1000];\r\n\r\n    if (config && RETRY_COUNT) {\r\n      // 设置用于跟踪重试计数的变量\r\n      config.__retryCount = config.__retryCount || 0;\r\n      // 检查是否已经把重试的总数用完\r\n      if (config.__retryCount >= RETRY_COUNT) {\r\n        return Promise.reject(response || { message: error.message });\r\n      }\r\n      // 增加重试计数\r\n      config.__retryCount++;\r\n      // 创造新的Promise来处理指数后退\r\n      const backoff = new Promise<void>((resolve) => {\r\n        setTimeout(() => {\r\n          resolve();\r\n        }, RETRY_DELAY || 1);\r\n      });\r\n      // instance重试请求的Promise\r\n      return backoff.then(() => {\r\n        return instance(config);\r\n      });\r\n    }\r\n\r\n    return Promise.reject(response);\r\n  } else {\r\n    // 处理断网的情况\r\n    // eg:请求超时或断网时，更新state的network状态\r\n    // network状态在app.vue中控制着一个全局的断网提示组件的显示隐藏\r\n    // 后续增加断网情况下做的一些操作\r\n    store.commit('networkState', false);\r\n  }\r\n}\r\n)\r\n// 只需要考虑单一职责，这块只封装axios\r\nexport default instance\r\n"
        }
    ]
}